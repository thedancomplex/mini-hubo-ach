//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.3603
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.IO;



namespace miniHubo
{


	public class IK2D
	{
		public double LH 	= 	91;		// mini hubo upper leg length (mm)
		public double LK	=	91;		// mini hubo lower leg length (mm)
		
		public int numberOfMotors = 22;
		
		// left leg offsets
		public int LHR	= 	0;	
		public int LHP 	=	1;
		public int LHY	= 	2;
		public int LKN	=	3;
		public int LAR	=	4;
		public int LAP	=	5;
		
		/*
		// left leg direction
		public int LHRd	= 	1;	
		public int LHPd	=	1;
		public int LHYd	= 	1;
		public int LKNd	=	1;
		public int LARd	=	1;
		public int LAPd	=	1;
		// left leg motor num
		public int LHRm	= 	1;	
		public int LHPm	=	2;
		public int LHYm	= 	3;
		public int LKNm	=	4;
		public int LARm	=	5;
		public int LAPm	=	6;
		
		
		//*/
		//right leg offsets
		public int RHR	= 	6;	
		public int RHP 	=	7;
		public int RHY	= 	8;
		public int RKN	=	9;
		public int RAR	=	10;
		public int RAP	=	11;
		/*
		// right leg directions
		public int RHRd	= 	1;	
		public int RHPd =	1;
		public int RHYd	= 	1;
		public int RKNd	=	1;
		public int RARd	=	1;
		public int RAPd	=	1;
		
		// right leg motor num
		public int RHRm	= 	7;	
		public int RHPm =	8;
		public int RHYm	= 	9;
		public int RKNm	=	10;
		public int RARm	=	11;
		public int RAPm	=	12;
		
		*/
		// left upper body offsets
		public int LSP	=	12;
		public int LSR	= 	13;
		public int LSY 	=	14;
		public int LEB	= 	15;
		
		/*
		// left upper body directions
		public int LSPd	=	1;
		public int LSRd	= 	1;
		public int LSYd	= 	1;
		public int LEBd	= 	1;
		
		// left upper body motor num
		public int LSPm	=	13;
		public int LSRm	= 	14;
		public int LSYm	= 	15;
		public int LEBm	= 	16;
		*/
		// right upper body offsets
		public int RSP	=	16;
		public int RSR	= 	17;
		public int RSY	= 	18;
		public int REB	= 	19;
		
		/*
		// right upper body directions
		public int RSPd	=	1;
		public int RSRd	= 	1;
		public int RSYd	= 	1;
		public int REBd	= 	1;
		
		// right upper body motor num
		public int RSPm	=	17;
		public int RSRm	= 	18;
		public int RSYm	= 	19;
		public int REBm	= 	20;
		*/
		
		// mis upper body offsets
		public int NK	=	20;
		public int WST	=	21;
		/*
		// mis upper body directions
		public int NKd	=	1;
		public int WSTd	=	1;
		
		// mis upper body motor num
		public int NKm	=	21;
		public int WSTm	=	22;
		*/
		
		public double[] motorNum;
		public double[]	motorDir;
		public double[] motorOfset;
		public string[] motorName;
		public double[] motorDesAngle;
		public double[] motorDesAngleWithOffset;
		public double[] motorDesAngleWithOffsetIK;
		public double[] motorIK;
		public byte[] motorComplianceSlope;
		
		public double x0 	= 	0;		// mini hubo x origin
		public double z0	=	0;		// mini hubo z origin
		public double y0	=	0;		// mini hub0 y origin
		
		public IK2D ()
		{
			motorNum = new double[numberOfMotors];
			motorDir = new double[numberOfMotors];
			motorOfset = new double[numberOfMotors];
			motorName = new string[numberOfMotors];
			motorDesAngle = new double[numberOfMotors];
			motorDesAngleWithOffset = new double[numberOfMotors];
			motorDesAngleWithOffsetIK = new double[numberOfMotors];
			motorIK = new double[numberOfMotors];
			motorComplianceSlope = new byte[numberOfMotors];
			
			for(int i = 0; i<numberOfMotors ; i++)
			{
				motorDesAngle[i] = 0;
			}
			
			motorName[LHR] = "LHR";
			motorName[LHP] = "LHP";
			motorName[LHY] = "LHY";
			motorName[LKN] = "LKN";
			motorName[LAP] = "LAP";
			motorName[LAR] = "LAR";
			
			motorName[RHR] = "RHR";
			motorName[RHP] = "RHP";
			motorName[RHY] = "RHY";
			motorName[RKN] = "RKN";
			motorName[RAP] = "RAP";
			motorName[RAR] = "RAR";
			
			motorName[RSP] = "RSP";
			motorName[RSY] = "RSY";
			motorName[RSR] = "RSR";
			motorName[REB] = "REB";
			
			motorName[LSP] = "LSP";
			motorName[LSY] = "LSY";
			motorName[LSR] = "LSR";
			motorName[LEB] = "LEB";
			
			motorName[NK] = "NK";
			motorName[WST] = "WST";
			
			
			
		}
		
		public void setMotorValues()
		{
			// set the motor values including the offset
			for( int i = 0; i< numberOfMotors; i++)
			{
				motorDesAngleWithOffset[i] = motorDir[i]*motorDesAngle[i]+motorOfset[i];	
				motorDesAngleWithOffsetIK[i] = motorDir[i]*(motorIK[i]-motorDesAngle[i])+motorOfset[i];
			}
		}
		public void ini(string fileName)
		{
			// sets the initial values of the robot including the zeroing and lengths
			
			
			StreamReader sr;
			string s;
			sr = File.OpenText(fileName);
			s = sr.ReadLine();
			
			string CMD;			// joint command
			string motorNum;	// motor number
			string angle;			// value
			string direct;		// direction
			string IK;			// IK offset
			
			while(s!=null)
			{
				int iVal = 0;
				while(s.Substring(iVal,1) != "=")		//get the CMD
				{
					iVal++;
				}
				
				CMD = s.Substring(0,iVal);
				iVal++;
				
				int iMotor = iVal;
				while(s.Substring(iMotor,1) != ",")		// get motor num
				{
					iMotor++;
				}
				
				motorNum = s.Substring(iVal,(iMotor-iVal));
				iMotor++;
				
				int iAngle = iMotor;
				while(s.Substring(iAngle,1) !=",")		// get motor offset
				{
					iAngle++;
				}
				
				angle = s.Substring(iMotor,(iAngle-iMotor));
				iAngle++;
				
				int iIK = iAngle;
				while(s.Substring(iIK,1) != ",")
				{
					iIK++;
				}
				
				IK = s.Substring(iAngle,(iIK-iAngle));
				iIK++;
				
				
				direct = s.Substring(iIK,(s.Length-iIK));
				setIniValues(CMD, motorNum, angle, IK, direct);
				s = sr.ReadLine();
			}
			
			
		}
		
		private void setIniValues(string CMD, string mNum, string degree, string IK, string direct)
		{
			double deg = 0;
			try{
				deg = double.Parse(degree);				
			}
			catch(Exception e)
			{}
			
			double IIK = 0;
			try{
				IIK = double.Parse(IK);				
			}
			catch(Exception e)
			{}
			
			int dirr = 1;
			try{
				dirr = int.Parse(direct);
			}
			catch(Exception e)
			{}
			
			int motor = 0;
			try{
				motor = int.Parse(mNum);
			}
			catch(Exception e)
			{}
			
			for(int i = 0; i<numberOfMotors; i++)
			{
				if(CMD == motorName[i])
				{
					motorDir[i] = dirr;
					motorNum[i] = motor;
					motorOfset[i] = deg;
					motorIK[i] = IIK;
				}
			}
			
			 
			
		}
		
		/*
		private void setIniValues(string CMD, string motorNum, string deg, string direct)
		{
			double valu = 0;
			try{
				valu = double.Parse(deg);				
			}
			catch(Exception e)
			{}
			
			int dirr = 1;
			try{
				dirr = int.Parse(direct);
			}
			catch(Exception e)
			{}
			
			int motor = 0;
			try{
				motor = int.Parse(motorNum);
			}
			catch(Exception e)
			{}
			
			
			
			 
			
			if(CMD == "LHP")
			{
				LHP = valu;
				LHPd = dirr;
				LHPm = motor;
			}
			else if(CMD == "LHR")
			{
				LHR = valu;
				LHRd = dirr;
				LHRm = motor;
			}		
			else if(CMD == "LHY")
			{
				LHY = valu;
				LHYd = dirr;
				LHYm = motor;
			}else if(CMD == "LKN")
			{
				LKN = valu;
				LKNd = dirr;
				LKNm = motor;
			}else if(CMD == "LAP")
			{
				LAP = valu;
				LAPd = dirr;
				LAPm = motor;
			}else if(CMD == "LAR")
			{
				LAR = valu;
				LARd = dirr;
				LARm = motor;
			}
			else if(CMD == "RHP")
			{
				RHP = valu;
				RHPd = dirr;
				RHPm = motor;
			}
			else if(CMD == "RHR")
			{
				RHR = valu;
				RHRd = dirr;
				RHRm = motor;
			}		
			else if(CMD == "RHY")
			{
				RHY = valu;
				RHYd = dirr;
				RHYm = motor;
			}else if(CMD == "RKN")
			{
				RKN = valu;
				RKNd = dirr;
				RKNm = motor;
			}else if(CMD == "RAP")
			{
				RAP = valu;
				RAPd = dirr;
				RAPm = motor;
			}else if(CMD == "RAR")
			{
				RAR = valu;
				RARd = dirr;
				RARm = motor;
			}
			else if(CMD == "NK")
			{
				NK = valu;
				NKd = dirr;
				NKm = motor;
			}else if(CMD == "WST")
			{
				WST = valu;
				WSTd = dirr;
				WSTm = motor;
			}
		}
		*/  // bad INI
		public double[] getIK2D(double LLH, double LLK, double xx0, double zz0, double x, double z)
		{
			// returns the 2D IK for putting the foot at x, z
			// returns [TH, TK, TA] in deg form
			// added offsets to move to outputs for the mini hubo (read from file)
			
			double[] theOut = new double[3];
			
			double xt = x-xx0;
			double zt = z-zz0;
			double LD = Math.Sqrt(xt*xt+zt*zt);	// Desired length from origin to end effector
			double TD = Math.Atan(xt/zt);		// Desired angle from origin to end effector in rad
			
			double T1 = Math.Acos((LLK*LLK-LD*LD-LLH*LLH)/(-2*LD*LLH));		// Theta 1
			double LD1 = Math.Cos(T1)*LLH;
			double LD2 = LD-LD1;
			
			double cHold = Math.Acos(LD2/LLK);
			
			double TH = Math.PI/2-TD-T1;			// Hip pitch angle
			double TK = Math.PI/2+TH+TD-cHold;		// knee pitch angle
			double TA = Math.PI/2-TD-cHold;			// ankle pitch angle
			
			theOut[0] = TH*180/Math.PI;
			theOut[1] = TK*180/Math.PI;
			theOut[2] = TA*180/Math.PI;
			
			theOut[0] = theOut[0]-90;
			theOut[1] = 180-theOut[1];
			theOut[2] = theOut[2]-90;
			
			return theOut;
		}
		public double[] getIK2DHip(double LL, double y)
		{
			// LL = current leg length
			// y = desired y offset
			double[] theOut = new double[2];
			
			double THR = 90-Math.Acos(y/LL)*180/Math.PI;		// theta hip roll
			double TAR = -THR;								// theta ankle roll
			
			theOut[0] = THR;
			theOut[1] = TAR;
			
			return theOut;
			
			
		}
		/*
		public double[] getIK2D(double LLH, double LLK, double xx0, double zz0, double x, double z)
		{
			// returns the 2D IK for putting the foot at x, z
			// returns [TH, TK, TA] in deg form
			
			
			double[] theOut = new double[3];
			
			double xt = x-xx0;
			double zt = z-zz0;
			double LD = Math.Sqrt(xt*xt+zt*zt);	// Desired length from origin to end effector
			double TD = Math.Atan(xt/zt);		// Desired angle from origin to end effector in rad
			
			double T1 = Math.Acos((LLK*LLK-LD*LD-LLH*LLH)/(-2*LD*LLH));		// Theta 1
			double LD1 = Math.Cos(T1)*LLH;
			double LD2 = LD-LD1;
			
			double cHold = Math.Acos(LD2/LLK);
			
			double TH = Math.PI/2-TD-T1;			// Hip pitch angle
			double TK = Math.PI/2+TH+TD-cHold;		// knee pitch angle
			double TA = Math.PI/2-TD-cHold;			// ankle pitch angle
			
			theOut[0] = TH*180/Math.PI;
			theOut[1] = TK*180/Math.PI;
			theOut[2] = TA*180/Math.PI;
			
			return theOut;
		}
		*/
		
	}
}
